##
# Copyright 2009-2012 Stijn Deweirdt, Dries Verdegem, Kenneth Hoste, Pieter De Baets, Jens Timmerman
#
# This file is part of EasyBuild,
# originally created by the HPC team of the University of Ghent (http://ugent.be/hpc).
#
# http://github.com/hpcugent/easybuild
#
# EasyBuild is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation v2.
#
# EasyBuild is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with EasyBuild.  If not, see <http://www.gnu.org/licenses/>.
##
import fileinput
import glob
import re
import os
import shutil
import sys
from easybuild.framework.application import Application
from easybuild.tools.filetools import run_cmd
from easybuild.tools.toolkit import get_openmp_flag

class CP2K(Application):

    def __init__(self, *args, **kwargs):
        Application.__init__(self, *args, **kwargs)

        self.cfg.update({'type':['popt',"Type of build ('popt' or 'psmp') (default: 'popt)"],
                         'typeopt':[True,"Enable optimization (default: True)"],
                         'libint':[True,"Use LibInt (default: True)"],
                         'modincprefix':['',"IMKL prefix for modinc include dir (default: '')"],                         
                         'modinc':[[],"List of modinc's to use (*.f90), or 'True' to use all found at given prefix (default: [])"],
                         'extracflags':['',"Extra CFLAGS to be added (default: '')"],
                         'extradflags':['',"Extra DFLAGS to be added (default: '')"],
                         })

        self.typearch = None

        # this should be set to False for old versions of GCC (e.g. v4.1)
        self.compilerISO_C_BINDING = True

        # compiler options that need to be set in Makefile
        self.debug = ''
        self.fpic = ''

        self.libsmm = ''
        self.modincpath = ''
        self.openmp = ''

    def _generateMakefile(self, options, makeInstructions=''):
        """Generate Makefile based on options dictionary and optional make instructions"""

        text = "# Makefile generated by CP2K._generateMakefile, items might appear in random order\n"
        for key, value in options.iteritems():
            text += "%s = %s\n" % (key, value)
        return text + makeInstructions

    def configure(self):
        """Configure build
        - build Libint wrapper
        - generate Makefile
        """

        # set compilers options according to toolkit config
        ## full debug: -g -traceback -check all -fp-stack-check
        ## -g links to mpi debug libs
        if self.tk.opts['debug']:
            self.debug = '-g'
            self.log.info("Debug build")
        if self.tk.opts['pic']:
            self.fpic = "-fPIC"
            self.log.info("Using fPIC")

        # report on extra flags being used
        if self.getcfg('extracflags'):
            self.log.info("Using extra CFLAGS: %s" % self.getcfg('extracflags'))
        if self.getcfg('extradflags'):
            self.log.info("Using extra CFLAGS: %s" % self.getcfg('extradflags'))

        # libsmm support
        if os.environ.has_key('SOFTROOTLIBSMM'):
            libsmms = glob.glob(os.path.join(os.environ['SOFTROOTLIBSMM'], 'lib') + '/libsmm_*nn.a')
            moredflags = ' ' + ' '.join([os.path.basename(os.path.splitext(x)[0]).replace('lib', '-D__HAS_') for x in libsmms])
            self.updatecfg('extradflags', moredflags)
            self.libsmm = ' '.join(libsmms)
            self.log.debug('Using libsmm %s (extradflags %s)' % (self.libsmm, moredflags))

        # obtain list of modinc's to use
        if self.getcfg("modinc"):
            self.modincpath = self.prepmodinc()

        # set typearch
        self.typearch = "Linux-x86-64-%s" % self.tk.name

        # compiler toolkit specific configuration
        icc = os.getenv('SOFTROOTICC')
        ifort = os.getenv('SOFTROOTIFORT')
        gcc = os.getenv('SOFTROOTGCC')

        if icc and ifort and not gcc:
            options = self.configureIntelBased()
        elif gcc and not (icc or ifort):
            options = self.configureGCCBased()
        else:
            self.log.error("Don't know how to tweak configuration for compiler used.")

        if os.getenv('SOFTROOTIMKL'):
            options = self.configureMKL(options)
        elif os.getenv('SOFTROOTACML'):
            options = self.configureACML(options) 

        if os.getenv('SOFTROOTFFTW'):
            options = self.configureFFTW(options)

        if os.getenv('SOFTROOTLAPACK'):
            options = self.configureLAPACK(options)

        if os.getenv('SOFTROOTSCALAPACK'):
            options = self.configureScaLAPACK(options)

        options['LIBS'] = "-Wl,--start-group %s -Wl,--end-group" % options['LIBS']

        makeInstructions = "graphcon.o: graphcon.F\n\t$(FC) -c $(FCFLAGS2) $<\n"

        # create arch file using options set
        archfile = os.path.join(self.getcfg('startfrom'), 'arch', 
                                '%s.%s' % (self.typearch, self.getcfg('type')))
        try:
            txt = self._generateMakefile(options, makeInstructions)
            f = open(archfile, 'w')
            f.write(txt)
            f.close()
            self.log.info("Content of makefile (%s):\n%s" % (archfile, txt))
        except:
            self.log.error("Writing makefile %s failed" % archfile)

    def prepmodinc(self):
        """Prepare list of module files"""

        self.log.debug("Preparing module files")

        softrootimkl = os.getenv('SOFTROOTIMKL')

        if softrootimkl:

            ## prepare modinc target path
            modincpath = os.path.join(self.builddir, 'modinc')
            self.log.debug("Preparing module files in %s" % modincpath)

            try:
                os.mkdir(modincpath)
            except OSError, err:
                self.log.error("Failed to create directory for module include files: %s" % err)

            ## get list of modinc source files
            modincdir = os.path.join(softrootimkl, self.getcfg("modincprefix"), 'include')

            if type(self.getcfg("modinc")) == list:
                modfiles = [os.path.join(modincdir, x) for x in self.getcfg("modinc")]

            elif type(self.getcfg("modinc")) == bool and type(self.getcfg("modinc")):
                modfiles = glob.glob(os.path.join(modincdir, '*.f90'))

            else:
                self.log.error("prepmodinc: Please specify either a boolean value " \
                               "or a list of files in modinc (found: %s)." % 
                               self.getcfg("modinc"))

            f77 = os.getenv('F77')
            if not f77:
                self.log.error("F77 environment variable not set, can't continue.")

            ## create modinc files
            for f in modfiles:
                if f77.endswith('ifort') :
                    cmd = "%s -module %s -c %s" % (f77, modincpath, f)
                elif f77 in ['gfortran', 'mpif77'] :
                    cmd = "%s -J%s -c %s" % (f77, modincpath, f)
                else:
                    self.log.error("prepmodinc: Unknown value specified for F77 (%s)" % f77)

                run_cmd(cmd, log_all=True, simple=True)

            return modincpath
        else:
            self.log.error("Don't know how to prepare modinc, IMKL not found")

    def configureCommon(self):
        """Common configuration for all toolkits"""

        # openmp introduces 2 major differences
        ## -automatic is default: -noautomatic -auto-scalar
        ## some mem-bandwidth optimisation
        if self.getcfg('type') == 'psmp':
            self.openmp = get_openmp_flag(self.log)

        # determine which opt flags to use
        if self.getcfg('typeopt'):
            optflags = 'OPT'
            regflags = 'OPT2'
        else:
            optflags = 'NOOPT'
            regflags = 'NOOPT'

        # make sure a MPI-2 able MPI lib is used
        mpi2libs = ['impi', 'MVAPICH2', 'OpenMPI']
        mpi2 = False
        for mpi2lib in mpi2libs:
            if os.getenv('SOFTROOT%s' % mpi2lib.upper()):
                mpi2 = True
            else:
                self.log.debug("MPI-2 supporting MPI library %s not loaded.")
        
        if not mpi2:
            self.log.error("CP2K needs MPI-2, no known MPI-2 supporting library loaded?")

        options = {
            'CC': os.getenv('MPICC'),
            'CPP': '',

            'FC': '%s %s' % (os.getenv('MPIF77'), self.openmp),
            'LD': '%s %s' % (os.getenv('MPIF77'), self.openmp),
            'AR': 'ar -r',

            'CPPFLAGS': '',
            
            'FPIC': self.fpic,
            'DEBUG': self.debug,

            'FCFLAGS': '$(FCFLAGS%s)' % optflags,
            'FCFLAGS2': '$(FCFLAGS%s)' % regflags,

            'CFLAGS' : ' $(SOFTVARCPPFLAGS) $(SOFTVARLDFLAGS) $(FPIC) $(DEBUG) %s ' % self.getcfg('extracflags'),
            'DFLAGS': ' -D__parallel -D__BLACS -D__SCALAPACK -D__FFTSG %s' % self.getcfg('extradflags'),

            'LIBS': os.getenv('LIBS'),

            'FCFLAGSNOOPT': '$(DFLAGS) $(CFLAGS) -O0  $(FREE) $(FPIC) $(DEBUG)',
            'FCFLAGSOPT': '-O2 $(FREE) $(SAFE) $(FPIC) $(DEBUG)',
            'FCFLAGSOPT2': '-O1 $(FREE) $(SAFE) $(FPIC) $(DEBUG)',
        }

        if self.getcfg('libint'):

            softrootlibint = os.getenv('SOFTROOTLIBINT')
            if not softrootlibint:
                self.log.error("LibInt module not loaded.")

            options['DFLAGS'] += ' -D__LIBINT'

            libintcompiler = "%s %s" % (os.getenv('CC'), os.getenv('CFLAGS'))

            # Build libint-wrapper, if required
            libint_wrapper = ''

            ## required for old versions of GCC
            if not self.compilerISO_C_BINDING:
                options['DFLAGS'] += ' -D__HAS_NO_ISO_C_BINDING'

                ## determine path for libint_tools dir
                libinttools_paths = ['libint_tools', 'tools/hfx_tools/libint_tools']
                libinttools_path = None
                for path in libinttools_paths:
                    path = os.path.join(self.getcfg('startfrom'), path)
                    if os.path.isdir(path):
                        libinttools_path = path
                        os.chdir(libinttools_path)
                if not libinttools_path:
                    self.log.error("No libinttools dir found")

                ## build libint wrapper
                cmd = "%s -c libint_cpp_wrapper.cpp -I%s/include" % (libintcompiler, softrootlibint)
                if not run_cmd(cmd, log_all=True, simple=True):
                    self.log.error("Building the libint wrapper failed")
                libint_wrapper = '%s/libint_cpp_wrapper.o' % libinttools_path

            # determine LibInt libraries based on major version number
            libint_maj_ver = os.getenv('SOFTVERSIONLIBINT').split('.')[0]
            if libint_maj_ver == '1':
                libint_libs = "$(LIBINTLIB)/libderiv.a $(LIBINTLIB)/libint.a $(LIBINTLIB)/libr12.a"
            elif libint_maj_ver == '2':
                libint_libs = "$(LIBINTLIB)/libint2.a"
            else:
                self.log.error("Don't know how to handle libint version %s" % libint_maj_ver)
            self.log.info("Using LibInt version %s" % (libint_maj_ver))

            options['LIBINTLIB'] = '%/lib' % softrootlibint
            options['LIBS'] += ' -lstdc++ %s %s' % (libint_libs, libint_wrapper)

        return options

    def configureIntelBased(self):
        """Configure for Intel based toolkits"""

        options = self.configureCommon()

        options.update({

            ## -Vaxlib : older options
            'FREE': '-fpp -free',

            #SAFE = -assume protect_parens -fp-model precise -ftz # problems
            'SAFE': '-assume protect_parens -no-unroll-aggressive',

            'INCFLAGS': '$(DFLAGS) -I$(INTEL_INC) -I$(INTEL_INCF) -I%s' % self.modincpath,

            'LDFLAGS': '$(INCFLAGS) -i-static',
            'OBJECTS_ARCHITECTURE': 'machine_intel.o',

        })

        options['DFLAGS'] += ' -D__INTEL'

        options['FCFLAGSOPT'] += '$(INCFLAGS) -xHOST -heap-arrays 64 -funroll-loops'
        options['FCFLAGSOPT2'] += '$(INCFLAGS) -xHOST -heap-arrays 64'

        return options

    def configureGCCBased(self):
        """Configure for GCC based toolkits"""
        options = self.configureCommon()

        options.update({

            ## need this to prevent "Unterminated character constant beginning" errors
            'FREE': '-ffree-form -ffree-line-length-none',

            'LDFLAGS': '$(FCFLAGS)',
            'OBJECTS_ARCHITECTURE': 'machine_gfortran.o',
        })

        options['DFLAGS'] += ' -D__GFORTRAN'

        options['FCFLAGSOPT'] += ' $(DFLAGS) $(CFLAGS) -march=native -ffast-math ' \
                                 '-funroll-loops -ftree-vectorize -fmax-stack-var-size=32768'
        options['FCFLAGSOPT2'] += ' $(DFLAGS) $(CFLAGS) -march=native'

        return options

    def configureACML(self, options):
        """Configure for AMD Math Core Library (ACML)"""

        openmp_suffix = ''
        if self.openmp:
            openmp_suffix = '_mp'

        options['ACML_INC'] = '$(SOFTROOTACML)/gfortran64%s/include' % openmp_suffix
        options['CFLAGS'] += ' -I$(ACML_INC) -I$(FFTW_INC)'
        options['DFLAGS'] += ' -D__FFTACML'

        blas = os.getenv('LIBBLAS')
        blas = blas.replace('gfortran64', 'gfortran64%s' % openmp_suffix)
        options['LIBS'] += ' %s $(LIBSCALAPACK) %s' % (self.libsmm, blas)

        return options

    def configureMKL(self, options):
        """Configure for Intel Math Kernel Library (MKL)"""

        options.update({
            'INTEL_INC': '$(MKLROOT)/include',
            'INTEL_INCF': '$(INTEL_INC)/fftw',
        })
        
        options['DFLAGS'] += ' -D__FFTW3 -D__FFTMKL'

        options['CFLAGS'] += ' -I$(INTEL_INC) -I$(INTEL_INCF) -I%s $(FPIC) $(DEBUG)' % self.modincpath
        
        options['LIBS'] += ' %s $(LIBSCALAPACK)' % self.libsmm

        return options

    def configureFFTW(self, options):
        """Configure for Fastest Fourier Transform in the West (FFTW)"""

        softroot = os.getenv('SOFTROOTFFTW')

        options.update({
                        'FFTW_INC': '%s/include' % softroot, # GCC
                        'FFTW3INC': '%s/include' % softroot, # Intel
                        'FFTW3LIB': '%s/lib' % softroot, # Intel
                        })

        options['DFLAGS'] += ' -D__FFTW3'

        options['LIBS'] += ' -lfftw3'

        return options

    def configureLAPACK(self, options):
        """Configure for LAPACK library"""

        options['LIBS'] += os.getenv('LIBLAPACK_MT')

        return options

    def configureScaLAPACK(self, options):
        """Configure for ScaLAPACK library"""

        options['LIBS'] += os.getenv('LIBSCALAPACK')

        return options

    def make(self):
        """Start the actual build
        - go into makefiles dir
        - patch Makefile
        - build
        """

        makefiles = os.path.join(self.getcfg('startfrom'), 'makefiles')
        try:
            os.chdir(makefiles)
        except:
            self.log.error("Can't change to makefiles dir %s: %s" % (makefiles))

        # modify makefile for parallel build
        parallel = self.getcfg('parallel')
        if parallel:

            try:
                for line in fileinput.input('Makefile', inplace=1, backup='.orig.patchictce'):
                    line = re.sub(r"^PMAKE\s*=.*$", "PMAKE\t= $(SMAKE) -j %s" % parallel, line)
                    sys.stdout.write(line)
            except IOError, err:
                self.log.error("Can't modify/write Makefile in %s: %s" % (makefiles, err))
    
        # update make options with ARCH and VERSION
        self.updatecfg('makeopts', 'ARCH=%s VERSION=%s' % (self.typearch, self.getcfg('type')))

        cmd = "make %s" % self.getcfg('makeopts')

        # clean first
        run_cmd(cmd + " clean", log_all=True, simple=True, log_output=True)

        # build
        run_cmd(cmd, log_all=True, simple=True, log_output=True)

    def make_install(self):
        """Install built CP2K
        - copy from exe to bin
        - copy tests
        """

        # copy executables
        targetdir = os.path.join(self.installdir, 'bin')
        exedir = os.path.join(self.getcfg('startfrom'), 'exe/%s' % self.typearch)
        try:
            if not os.path.exists(targetdir):
                os.makedirs(targetdir)
            os.chdir(exedir)
            for exefile in os.listdir(exedir):
                if os.path.isfile(exefile):
                    shutil.copy2(exefile, targetdir)
        except OSError, err:
            self.log.error("Copying executables from %s to bin dir %s failed: %s" % (exedir, 
                                                                                     targetdir, 
                                                                                     err) )

        # copy tests
        srctests = os.path.join(self.getcfg('startfrom'), 'tests')
        targetdir = os.path.join(self.installdir, 'tests')
        if os.path.exists(targetdir):
            self.log.info("Won't copy tests. Destination directory %s already exists" % targetdir)
        else:
            try:
                shutil.copytree(srctests, targetdir)
            except:
                self.log.error("Copying tests from %s to %s failed" % (srctests, targetdir))

    def sanitycheck(self):
        """Custom sanity check for CP2K"""

        if not self.getcfg('sanityCheckPaths'):
            cp2k_type = self.getcfg('type')
            self.setcfg('sanityCheckPaths',{'files':["bin/%s.%s" % (x, cp2k_type) for x in ["cp2k",
                                                                                            "cp2k_shell",
                                                                                            "fes"]],
                                            'dirs':["tests"]
                                           })

            self.log.info("Customized sanity check paths: %s"%self.getcfg('sanityCheckPaths'))

        Application.sanitycheck(self)