diff -wru trunk_nosvn.orig/src/utils/SparseMatrixImpl.cpp trunk_nosvn/src/utils/SparseMatrixImpl.cpp
--- trunk_nosvn.orig/src/utils/SparseMatrixImpl.cpp	2012-07-31 13:55:50.000000000 +0200
+++ trunk_nosvn/src/utils/SparseMatrixImpl.cpp	2012-08-28 14:49:28.980688142 +0200
@@ -47,6 +47,28 @@
 { return (16+sizeof(int))*data.nonZeros()+sizeof(int)*data.cols(); };
 
 
+/* product of a matrix with a vector, but only use one row of the matrix */
+template<>
+dcomplex SparseMatrixImpl<dcomplex,Eigen::RowMajor>::product_onerow(int row, DenseMatrixImpl<dcomplex>& input ) {
+	return this->data.row(row).dot(input.data.col(0));
+};
+
+template<>
+double SparseMatrixImpl<double,Eigen::RowMajor>::product_onerow(int row, DenseMatrixImpl<double>& input ) {
+	return this->data.row(row).dot(input.data.col(0));
+};
+
+template<>
+dcomplex SparseMatrixImpl<dcomplex,Eigen::ColMajor>::product_onerow(int row, DenseMatrixImpl<dcomplex>& input ) {
+	debug_verbose(0,"Attempting to do (matrix_ij*vector_j)_i on a column major matrix! This is inefficient and was not yet needed, so quitting.\n");
+};
+
+template<>
+double SparseMatrixImpl<double,Eigen::ColMajor>::product_onerow(int row, DenseMatrixImpl<double>& input ) {
+	debug_verbose(0,"Attempting to do (matrix_ij*vector_j)_i on a column major matrix! This is inefficient and was not yet needed, so quitting.\n");
+};
+
+
 
 // ONLY FOR TESTING / CALLGRINDING
 /*
diff -wru trunk_nosvn.orig/src/utils/SparseMatrixImpl.h trunk_nosvn/src/utils/SparseMatrixImpl.h
--- trunk_nosvn.orig/src/utils/SparseMatrixImpl.h	2012-07-31 13:55:50.000000000 +0200
+++ trunk_nosvn/src/utils/SparseMatrixImpl.h	2012-08-28 14:49:28.988688229 +0200
@@ -126,9 +126,8 @@
 	/**
 	 * Product of one row with an input vector
 	 */
-	D product_onerow(int row, DenseMatrixImpl<D>& input ) {
-		return this->data.row(row).dot(input.data.col(0));
-	};
+	D product_onerow(int row, DenseMatrixImpl<D>& input );
+
 
 	/**
 	 * Sparse matrix product.
@@ -155,6 +154,10 @@
 	 */
 	void solve(SparseMatrixImpl<D,O>& x, SparseMatrixImpl<D,O>& b);
 
+	void addTranspose() {
+		data = Eigen::SparseMatrix<D,O,int>(data.transpose())+data;
+	};
+
 	inline SparseMatrixImpl<D,O>& operator+= (DenseMatrixImpl<D>& M2) {//(const SparseMatrixImpl<D,O>& M2) {
 			//data+=M2.data;
 			//TODO: implement this
