Patch from https://github.com/pytorch/pytorch/pull/50550 - "Fix nan compare for complex"
Edited, to apply to PyTorch 1.7.1, and added to EasyBuild by Simon Branford, University of Birmingham
diff --git a/test/test_unary_ufuncs.py b/test/test_unary_ufuncs.py
index 3c6a4f0e7b0a1..e6818929f567b 100644
--- a/test/test_unary_ufuncs.py
+++ b/test/test_unary_ufuncs.py
@@ -295,7 +295,17 @@ def test_reference_numerics(self, device, dtype, op):
             else:
                 msg = None
+
+            exact_dtype = True
+            if op.promotes_integers_to_float and dtype in integral_types() + (torch.bool,):
+                exact_dtype = False
+                if dtype in [torch.uint8, torch.int8, torch.bool]:
+                    # NOTE: For these dtypes, PyTorch computes in the default scalar type (float)
+                    # while NumPy computes in float16
+                    self.assertEqualHelper(actual, expected, msg, dtype=dtype,
+                                           exact_dtype=exact_dtype, rtol=1e-3, atol=1e-2)
+                    continue
 
-            self.assertEqualHelper(actual, expected, msg, dtype=dtype)
+            self.assertEqualHelper(actual, expected, msg, dtype=dtype, equal_nan="relaxed", exact_dtype=exact_dtype)
 
     # Tests for testing (dis)contiguity consistency
 
diff --git a/torch/testing/__init__.py b/torch/testing/__init__.py
index c26556f4d70a9..bfbff06a1435b 100644
--- a/torch/testing/__init__.py
+++ b/torch/testing/__init__.py
@@ -70,7 +70,8 @@ def _unravel_index(flat_index, shape):
 #
 #   Bool tensors are equal only if they are identical, regardless of
 #   the rtol and atol values.
-def _compare_tensors_internal(a: torch.Tensor, b: torch.Tensor, *, rtol, atol, equal_nan: bool) -> _compare_return_type:
+def _compare_tensors_internal(a: torch.Tensor, b: torch.Tensor, *, rtol, atol, equal_nan: Union[str, bool]) -> _compare_return_type:
+    assert equal_nan in {True, False, "relaxed"}
     debug_msg : Optional[str]
     # Integer (including bool) comparisons are identity comparisons
     # when rtol is zero and atol is less than one
@@ -104,8 +105,19 @@ def _compare_tensors_internal(a: torch.Tensor, b: torch.Tensor, *, rtol, atol, e
     # Compares complex tensors' real and imaginary parts separately.
     # (see NOTE Test Framework Tensor "Equality")
     if a.is_complex():
+        a = a.clone()
+        b = b.clone()
         a_real = a.real
         b_real = b.real
+        a_imag = a.imag
+        b_imag = b.imag
+
+        if equal_nan == "relaxed":
+            a_real[a_imag.isnan()] = math.nan
+            a_imag[a_real.isnan()] = math.nan
+            b_real[b_imag.isnan()] = math.nan
+            b_imag[b_real.isnan()] = math.nan
+
         real_result, debug_msg = _compare_tensors_internal(a_real, b_real,
                                                            rtol=rtol, atol=atol,
                                                            equal_nan=equal_nan)
@@ -114,8 +126,6 @@ def _compare_tensors_internal(a: torch.Tensor, b: torch.Tensor, *, rtol, atol, e
             debug_msg = "Real parts failed to compare as equal! " + cast(str, debug_msg)
             return (real_result, debug_msg)
 
-        a_imag = a.imag
-        b_imag = b.imag
         imag_result, debug_msg = _compare_tensors_internal(a_imag, b_imag,
                                                            rtol=rtol, atol=atol,
                                                            equal_nan=equal_nan)
@@ -126,6 +136,9 @@ def _compare_tensors_internal(a: torch.Tensor, b: torch.Tensor, *, rtol, atol, e
 
         return (True, None)
 
+    if equal_nan == "relaxed":
+        equal_nan = True
+
     # All other comparisons use torch.allclose directly
     if torch.allclose(a, b, rtol=rtol, atol=atol, equal_nan=equal_nan):
         return (True, None)
@@ -161,7 +174,7 @@ def _compare_tensors_internal(a: torch.Tensor, b: torch.Tensor, *, rtol, atol, e
 
 # Checks if two scalars are equal(-ish), returning (True, None)
 # when they are and (False, debug_msg) when they are not.
-def _compare_scalars_internal(a, b, *, rtol: float, atol: float, equal_nan: bool) -> _compare_return_type:
+def _compare_scalars_internal(a, b, *, rtol: float, atol: float, equal_nan: Union[str, bool]) -> _compare_return_type:
     def _helper(a, b, s) -> _compare_return_type:
         # Short-circuits on identity
         if a == b or (equal_nan and a != a and b != b):
@@ -197,6 +210,13 @@ def _helper(a, b, s) -> _compare_return_type:
         a = complex(a)
         b = complex(b)
 
+        if equal_nan == "relaxed":
+            if math.isnan(a.real) or math.isnan(a.imag):
+                a = complex(math.nan, math.nan)
+            if math.isnan(b.real) or math.isnan(b.imag):
+                b = complex(math.nan, math.nan)
+            equal_nan = True
+
         result, msg = _helper(a.real, b.real, " the real part ")
 
         if not result:
@@ -204,6 +224,9 @@ def _helper(a, b, s) -> _compare_return_type:
 
         return _helper(a.imag, b.imag, " the imaginary part ")
 
+    if equal_nan == "relaxed":
+        equal_nan = True
+
     return _helper(a, b, " ")
 
 def assert_allclose(actual, expected, rtol=None, atol=None, equal_nan=True, msg='') -> None:
